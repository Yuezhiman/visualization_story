<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>人物时间线</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://d3js.org/d3.v7.min.js"></script>
   <script src="js/events.js" defer></script>
</head>
<style>
    html, body {
      margin: 10;
      font-family: sans-serif;
      height: 100%;
      display: flex;
      flex-direction: column;
    }

#main {
    display: flex;
    flex: 1;
    overflow: hidden;
    justify-content: space-around;
}

#flower-plot {
      margin-top: 30px;
    }
    .flower-node {
      cursor: pointer;
      stroke: #eb1111;
      stroke-width: 1;
      opacity: 0.8;
    }
    .flower-label {
      font-size: 10px;
      fill: #e4d912;
    }
    .legend text {
      font-size: 12px;
      fill: #1790e7;
    }
#event-display {
    flex: 1;
    padding: 20px;
    overflow: auto;
    background: #f5f5f5;
}

#timeline {
    margin-top: 20px; 
    overflow-x: auto;
    white-space: nowrap;
    background: #f8f8f8;
    padding: 10px 0;  
}

.event-box {
    background: #fff;
    padding: 15px;
    border: 1px solid #ccc;
    max-width: 700px;
    margin: auto;
}


img, video {
    max-width: 100%;
    margin-top: 10px;
}
#controls button {
  margin: 5px;
  padding: 8px 12px;
  font-size: 16px;
  border-radius: 8px;
  border: none;
  background-color: #eee;
  cursor: pointer;
}
#controls button:hover {
  background-color: #ddd;
}

.event-marker, .flower-node {
    fill: gray;
    cursor: pointer;
    stroke: #000;
    stroke-width: 1;
}

.active {
    stroke: red;
    stroke-width: 3;
}

.marker-label {
    font-size: 12px;
    text-anchor: middle;
    fill: #fff;
    pointer-events: none;
}

.mountain {
    fill: lightgray;
    opacity: 0.4;
}

#media-container {
  width: 100%;
  text-align: center;
  margin-top: 10px;
}

.media-display {
  max-width: 100%;
  max-height: 300px;
  border-radius: 8px;
  object-fit: contain;
}


</style>
<body>

<div id="controls">
  <button onclick="startAutoPlay()">▶️ 播放</button>
  <button onclick="stopAutoPlay()">⏸ 暂停</button>
  <button id="prev">⏮️ 上一条</button>
</div>

<div id="main">
  <div id="flower-plot"></div>
  <div id="event-display">
    <h2 id="event-title"></h2>
    <p id="event-time"></p>
  <p id="event-description"></p>
  <div id="media-display"></div>
  </div>
  

</div>

<div id="timeline"></div>

<script>

let currentIndex = 0;
let autoplayTimer = null;
let isManualInterruption = false;  

const peakThreshold = 0.6;
const categoryColor = {
  "职业": "#4CAF50",
  "家庭": "#2196F3",
  "社会责任": "#FFC107",
  "其他": "#9E9E9E"
};
function renderFlowerPlot() {
  const width = 500;
  const height = 500;
  const center = { x: width / 2, y: height / 2 };
  const radius = 120;
  const peakThreshold = 0.6;
  const categoryColor = {
    "职业": "#4CAF50",
    "家庭": "#2196F3",
    "社会责任": "#FFC107",
    "其他": "#9E9E9E"
  };

  const svg = d3.select("#flower-plot")
    .append("svg")
    .attr("width", width)
    .attr("height", height)
    .attr("viewBox", `0 0 ${width} ${height}`)
    .attr("preserveAspectRatio", "xMidYMid meet");

  // 添加背景圆形
  svg.append("circle")
    .attr("cx", center.x)
    .attr("cy", center.y)
    .attr("r", radius + 60)
    .attr("fill", "rgba(215, 58, 58, 0.03)")
    .attr("stroke", "rgba(142, 225, 41, 0.05)")
    .attr("stroke-width", 1);
    
  // 添加阴影滤镜
  const defs = svg.append("defs");
  Object.entries(categoryColor).forEach(([category, color]) => {
    const gradient = defs.append("radialGradient")
      .attr("id", `grad-${category}`)
      .attr("cx", "50%").attr("cy", "50%").attr("r", "50%");
    gradient.append("stop").attr("offset", "0%").attr("stop-color", d3.color(color).brighter(1));
    gradient.append("stop").attr("offset", "100%").attr("stop-color", color);
  });
  defs.append("filter")
    .attr("id", "drop-shadow")
    .attr("x", "-50%")
    .attr("y", "-50%")
    .attr("width", "200%")
    .attr("height", "200%")
    .append("feDropShadow")
    .attr("dx", 0)
    .attr("dy", 2)
    .attr("stdDeviation", 3)
    .attr("flood-color", "rgba(240, 15, 15, 0.5)");
  
  // 添加装饰性圆圈
  for (let i = 0; i < 3; i++) {
    const r = radius + i * 20;
    svg.append("circle")
      .attr("cx", center.x)
      .attr("cy", center.y)
      .attr("r", r)
      .attr("fill", "none")
      .attr("stroke", `rgba(0, 0, 0, ${0.05 - i*0.01})`)
      .attr("stroke-width", 1)
      .attr("stroke-dasharray", i === 0 ? "4 2" : "2 2");
  }
  
  // 中心标题
  svg.append("text")
    .attr("x", center.x)
    .attr("y", center.y - 10)
    .attr("text-anchor", "middle")
    .attr("font-size", "18px")
    .attr("fill", "#2c3e50")
    .attr("font-weight", "bold")
    .text("人物生平概览");
    
  svg.append("text")
    .attr("x", center.x)
    .attr("y", center.y + 15)
    .attr("text-anchor", "middle")
    .attr("font-size", "14px")
    .attr("fill", "#a0a0d0");

  // 分离内部和外部事件
  const inside = events.filter(d => d.peak >= peakThreshold);
  const outside = events.filter(d => d.peak < peakThreshold);
  
  
  // 计算位置
  inside.forEach((d, i) => {
    const angle = (2 * Math.PI * i / inside.length) - Math.PI/2;
    d.x = center.x + radius * 0.6 * Math.cos(angle);
    d.y = center.y + radius * 0.6 * Math.sin(angle);
  });

  outside.forEach((d, i) => {
    const angle = (2 * Math.PI * i / outside.length) - Math.PI/2;
    d.x = center.x + radius * 1.4 * Math.cos(angle);
    d.y = center.y + radius * 1.4 * Math.sin(angle);
  });

  const all = [...inside, ...outside];

  // 添加连接线
  all.forEach(d => {
    svg.append("line")
      .attr("x1", center.x)
      .attr("y1", center.y)
      .attr("x2", center.x)
      .attr("y2", center.y)
      .attr("stroke", "rgba(0, 0, 0, 0.1)")
      .attr("stroke-width", 1)
      .transition()
      .duration(1000)
      .ease(d3.easeCubicOut)
      .attr("x2", d.x)
      .attr("y2", d.y);
  });

  // 添加事件点 - 使用纯色映射
  const nodes = svg.selectAll(".flower-node")
    .data(all)
    .enter()
    .append("circle")
    .attr("class", "flower-node")
    .attr("cx", center.x)
    .attr("cy", center.y)
    .attr("r", 0)
    // .style("fill", d => categoryColor[d.category] || "#9E9E9E")
    .style("fill", d => `url(#grad-${d.category})`)
    .attr("filter", "url(#drop-shadow)")
    .attr("stroke", "white")
    .attr("stroke-width", 0)
    .on("mouseover", function(event, d) {
      d3.select(this)
        .attr("stroke-width", 2)
        .attr("r", 8 + d.peak * 6);
    })
    .on("mouseout", function(event, d) {
      d3.select(this)
        .attr("stroke-width", 0)
        .attr("r", 6 + d.peak * 6);
    })
    .on("click", function(event, d) {
      showEvent(d);
    });
    
  // 动画效果
  nodes.transition()
    .duration(1200)
    .ease(d3.easeElasticOut)
    .attr("cx", d => d.x)
    .attr("cy", d => d.y)
    .attr("r", d => 6 + d.peak * 6)
    .attr("opacity", 1);
    
  // 添加事件标题
  svg.selectAll(".flower-label")
    .data(all)
    .enter()
    .append("text")
    .attr("class", "flower-label")
    .attr("x", center.x)
    .attr("y", center.y)
    .attr("text-anchor", "middle")
    .attr("font-size", "10px")
    .attr("fill", "rgba(0, 0, 0, 0)")
    .attr("pointer-events", "none")
    .text(d => d.title)
    .transition()
    .delay(1000)
    .duration(500)
    .attr("x", d => d.x)
    .attr("y", d => d.y + (d.peak >= peakThreshold ? 25 : 30))
    .attr("fill", "rgba(0, 0, 0, 0.8)");

  // 图例
   const legend = svg.append("g")
    .attr("transform", `translate(20, ${height - 100})`);

  Object.entries(categoryColor).forEach(([category, color], i) => {
    const g = legend.append("g")
      .attr("transform", `translate(0, ${i * 22})`);
    g.append("circle")
      .attr("r", 8)
      .attr("fill", `url(#grad-${category})`);
    g.append("text")
      .attr("x", 15)
      .attr("y", 5)
      .text(category)
      .attr("fill", "#333")
      .attr("font-size", "14px");
  });
}
function renderTimeline() {
  const timelineDiv = document.getElementById("timeline");
  timelineDiv.innerHTML = ""; // 清空旧图
  timelineDiv.style.overflowX = "auto";

  const svgWidth = 2000;
  const svgHeight = 200;

  const timeline = d3.select(timelineDiv).append("svg")
    .attr("width", svgWidth)
    .attr("height", svgHeight);

  const x = d3.scaleTime()
    .domain([
      d3.min(events, d => d.start),
      d3.max(events, d => d.end)
    ])
    .range([60, svgWidth - 60]);

  const area = d3.area()
    .x(d => x(d.start))
    .y0(svgHeight)
    .y1(d => svgHeight - (d.peak || 0) * 100)
    .curve(d3.curveMonotoneX); // 使用平滑曲线
    // 使用曲线插值使山峰更平滑

  // 渐变色定义
  const defs = timeline.append("defs");
  const gradient = defs.append("linearGradient")
    .attr("id", "mountain-gradient")
    .attr("x1", "0%").attr("x2", "0%")
    .attr("y1", "0%").attr("y2", "100%");

  gradient.selectAll("stop")
    .data([
      { offset: "0%", color: "#80c1ff" },
      { offset: "100%", color: "#ffffff" }
    ])
    .enter()
    .append("stop")
    .attr("offset", d => d.offset)
    .attr("stop-color", d => d.color);

  // 山峰区域图
  timeline.append("path")
    .datum(events)
    .attr("class", "mountain")
    .attr("d", area)
    .attr("fill", "url(#mountain-gradient)");

  // 时间轴
  timeline.append("g")
    .attr("transform", "translate(0,180)")
    .call(d3.axisBottom(x).ticks(d3.timeYear.every(1)).tickFormat(d3.timeFormat("%Y")));

  // 时间段横条
  timeline.selectAll(".duration-bar")
    .data(events)
    .enter()
    .append("rect")
    .attr("class", "duration-bar")
    .attr("x", d => x(d.start))
    .attr("y", 150)
    .attr("height", 4)
    .attr("width", d => Math.max(2, x(d.end) - x(d.start)))
    .attr("fill", "#aaa")
    .on("click", (e, d) => showEvent(d));
  // 🏀 事件图标及标签（用箭头指向）
  const markers = timeline.selectAll(".event-marker")
    .data(events)
    .enter()
    .append("g")
    .attr("transform", d => `translate(${x(d.start)}, 180)`)
    .on("click", (e, d) => showEvent(d));

  // 🏀 图标（篮球）
  markers.append("text")
    .attr("text-anchor", "middle")
    .attr("font-size", "20px")
    .attr("y", 0)
    .text("🏀");



    // 在 timeline svg 内创建一个篮球图标（只一个）
  // ⬆️ 标签文字
  // 原来的 marker.append("text") 
  // 先创建空文本元素，不设置 text()
  const label = markers.append("text")
    .attr("y", (d, i) => i % 2 === 0 ? -45 : -70) // 上下交错
    .attr("text-anchor", "middle")
    .attr("font-size", "12px")
    .attr("font-family", "sans-serif")
    .attr("fill", "#000");

  // 用 tspan 分行写完整文本
  label.each(function(d) {
    const textLines = d.title.split("："); // 分行
    textLines.forEach((line, i) => {
      d3.select(this).append("tspan")
        .attr("x", 0)
        .attr("dy", i === 0 ? 0 : "1.2em")
        .text(line);
    });
  });

  // const label =markers.append("text")
  //   .attr("y", (d, i) => i % 2 === 0 ? -45 : -70) // 上下交错
  //   .attr("text-anchor", "middle")
  //   .attr("font-size", "12px")
  //   .attr("font-family", "sans-serif")
  //   .attr("fill", "#000")
  //   .text(d => d.title.length > 6 ? d.title.slice(0, 6) + "…" : d.title);
  // markers.each(function(d) {
  //   const text = d.title.split("："); // 分成多行，如：["奥运危机", "形成影响"]
  //   text.forEach((line, i) => {
  //     d3.select(this).append("tspan")
  //       .attr("x", 0)
  //       .attr("dy", i === 0 ? 0 : "1.2em")
  //       .text(line);
  //   });
  // });
  // markers.append("text")
  //   .attr("class", "marker-label")
  //   .attr("text-anchor", "middle")
  //   .attr("font-size", "10px")
  //   .attr("fill", "#000")
  //   .attr("y", -35)
  //   .text(d => d.title.length > 6 ? d.title.slice(0, 6) + "…" : d.title);

  // ⬆️ 箭头线条
  markers.append("line")
    .attr("x1", 0).attr("y1", -28)
    .attr("x2", 0).attr("y2", -5)
    .attr("stroke", "#999")
    .attr("stroke-width", 1);

  // Tooltip 提示（悬停完整标题 + 时间）
  markers.append("title")
    .text(d => `${d.title}：${d3.timeFormat("%Y-%m-%d")(d.start)} - ${d3.timeFormat("%Y-%m-%d")(d.end)}`);

  // 拖拽滚动逻辑
  let isDragging = false, startX = 0, scrollLeft = 0;
  timelineDiv.addEventListener("mousedown", e => {
    isDragging = true;
    startX = e.pageX - timelineDiv.offsetLeft;
    scrollLeft = timelineDiv.scrollLeft;
  });
  timelineDiv.addEventListener("mouseleave", () => isDragging = false);
  timelineDiv.addEventListener("mouseup", () => isDragging = false);
  timelineDiv.addEventListener("mousemove", e => {
    if (!isDragging) return;
    const xPos = e.pageX - timelineDiv.offsetLeft;
    const walk = (xPos - startX) * 1.5;
    timelineDiv.scrollLeft = scrollLeft - walk;
  });
}



// 
function showEvent(event, fromAutoplay = false) {
  let imageIndex = 0;
  if (!fromAutoplay) {
    // 用户点击时中断自动播放
    stopAutoPlay();
    isManualInterruption = true;
  }

  d3.selectAll(".event-marker").classed("active", e => e === event);
  d3.selectAll(".flower-node").classed("active", e => e === event);

  const display = d3.select("#event-display").html("");
  const box = display.append("div").attr("class", "event-box");
  const mediaBox = box.append("div").attr("class", "media-carousel");

  box.append("h2").text(event.title);
  box.append("p").text(event.description);
  // box中多张图片，模态，滚动呈现

  
  // if (event.image) {
  //   event.image.forEach(img => box.append("img").attr("src", "images/" + img));
  // }

  // if (event.video) {
  //   box.append("video")
  //     .attr("src", "videos/" + event.video)
  //     .attr("controls", true)
  //     .attr("autoplay", true);
  // }
//   if (event.image) {
//   event.image.forEach(img =>
//     mediaBox.append("img")
//       .attr("src", "images/" + img)
//       .attr("class", "media-item")
//   );
// }

// if (event.video) {
//   mediaBox.append("video")
//     .attr("src", "videos/" + event.video)
//     .attr("class", "media-item")
//     .attr("controls", true);
// }

const mediaContainer = box.append("div").attr("id", "media-container");
const controlBox = box.append("div").attr("class", "media-controls");

controlBox.append("button")
  .text("⏮️ 上一张")
  .on("click", () => {
    mediaIndex = (mediaIndex - 1 + mediaItems.length) % mediaItems.length;
    showMediaItem(mediaIndex);
  });

controlBox.append("button")
  .text("⏭️ 下一张")
  .on("click", () => {
    nextMedia();
  });

let mediaItems = [];
if (event.image) {
  event.image.forEach(img => {
    mediaItems.push({ type: "image", src: "images/" + img });
  });
}
if (event.video) {
  mediaItems.push({ type: "video", src: "videos/" + event.video });
}

let mediaIndex = 0;

function showMediaItem(index) {
  mediaContainer.html(""); // 清空容器
  const item = mediaItems[index];

  if (item.type === "image") {
    mediaContainer.append("img")
      .attr("src", item.src)
      .attr("class", "media-display");
    scheduleNext();
  } else if (item.type === "video") {
    const video = mediaContainer.append("video")
      .attr("src", item.src)
      .attr("class", "media-display")
      .attr("controls", true)
      .attr("autoplay", true)
      .node();

    video.onended = () => {
      nextMedia();
    };
  }
}

function nextMedia() {
  mediaIndex = (mediaIndex + 1) % mediaItems.length;
  showMediaItem(mediaIndex);
}

let mediaTimer = null;
function scheduleNext() {
  clearTimeout(mediaTimer);
  mediaTimer = setTimeout(() => {
    nextMedia();
  }, 4000); // 图片 4 秒切换
}

if (mediaItems.length > 0) {
  showMediaItem(mediaIndex);
}



}




// 设置自动播放events中的内容
let intervalId = null;
function startAutoPlay() {
  stopAutoPlay();
  isManualInterruption = false; // 重置标志

  autoplayTimer = setInterval(() => {
    if (!isManualInterruption) {
      showEvent(events[currentIndex], true); // 自动播放用 true
      currentIndex = (currentIndex + 1) % events.length;
    }
  }, 5000);
}


function stopAutoPlay() {
  if (autoplayTimer) {
    clearInterval(autoplayTimer);
    autoplayTimer = null;
  }
}
document.addEventListener("DOMContentLoaded", () => {
  renderFlowerPlot();
  renderTimeline();
  showEvent(events[0]);
  startAutoPlay();
});
</script>

</body>
</html>